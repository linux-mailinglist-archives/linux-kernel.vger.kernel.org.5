Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 00D2A8089D4
	for <lists+linux-kernel@lfdr.de>; Thu,  7 Dec 2023 15:07:09 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1442995AbjLGOG7 (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Thu, 7 Dec 2023 09:06:59 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:57324 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1442978AbjLGOG5 (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 7 Dec 2023 09:06:57 -0500
Received: from smtp.kernel.org (relay.kernel.org [52.25.139.140])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 8099B10C2
        for <linux-kernel@vger.kernel.org>; Thu,  7 Dec 2023 06:07:02 -0800 (PST)
Received: by smtp.kernel.org (Postfix) with ESMTPSA id 23BB1C433C9;
        Thu,  7 Dec 2023 14:07:02 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=k20201202; t=1701958022;
        bh=cZE6recoVJBKdwJhpx4lYW5auQfi5FwfjuprvRYlh1o=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=djX50MoaBv+/704ycHe+m7Gz/dhYtStLSzczs5PozYrzQ4DeGKjJ/B1igcoz76jH4
         D5AOKiNgYf8i3qN/SmV7Pp+adUHBxasOvSpxoS8wMzSxogR8XdhWdXFSCUepqCOdj6
         A3R7AyGfZtLukgkvApcZvyLqcG6iBEnn72jcU+GWoWpDZ5ZWu9OfVRofM8SJ0FHqTl
         b3tGOHgzebbfuRPoMEfOOhi4GtlXp6SuPEKQTFWyj9LePaBPbPU0bXL6ELRI4c9+Sf
         GvA01iPnQmx1MK6ps+CDNKHGMWWcSwgz9AxHK0ZWAc5VFzfmtVZGn+Z6kKlpI8N9xq
         YOB0lDorFZjJA==
Received: from ip-185-104-136-29.ptr.icomera.net ([185.104.136.29] helo=wait-a-minute.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.95)
        (envelope-from <maz@kernel.org>)
        id 1rBF1n-002ENN-Lw;
        Thu, 07 Dec 2023 14:06:59 +0000
Date:   Thu, 07 Dec 2023 14:06:34 +0000
Message-ID: <87bkb285ud.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     Mark Brown <broonie@kernel.org>
Cc:     Catalin Marinas <catalin.marinas@arm.com>,
        Will Deacon <will@kernel.org>,
        Oliver Upton <oliver.upton@linux.dev>,
        James Morse <james.morse@arm.com>,
        Suzuki K Poulose <suzuki.poulose@arm.com>,
        Jonathan Corbet <corbet@lwn.net>,
        Shuah Khan <shuah@kernel.org>,
        linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        kvmarm@lists.linux.dev, linux-doc@vger.kernel.org,
        linux-kselftest@vger.kernel.org
Subject: Re: [PATCH v3 15/21] KVM: arm64: Support FEAT_FPMR for guests
In-Reply-To: <08ae06c7-1654-4dfd-a789-b8e13c87d705@sirena.org.uk>
References: <20231205-arm64-2023-dpisa-v3-0-dbcbcd867a7f@kernel.org>
        <20231205-arm64-2023-dpisa-v3-15-dbcbcd867a7f@kernel.org>
        <87cyvi8kz1.wl-maz@kernel.org>
        <08ae06c7-1654-4dfd-a789-b8e13c87d705@sirena.org.uk>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/28.2
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-SA-Exim-Connect-IP: 185.104.136.29
X-SA-Exim-Rcpt-To: broonie@kernel.org, catalin.marinas@arm.com, will@kernel.org, oliver.upton@linux.dev, james.morse@arm.com, suzuki.poulose@arm.com, corbet@lwn.net, shuah@kernel.org, linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org, kvmarm@lists.linux.dev, linux-doc@vger.kernel.org, linux-kselftest@vger.kernel.org
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
X-Spam-Status: No, score=-2.1 required=5.0 tests=BAYES_00,DKIMWL_WL_HIGH,
        DKIM_SIGNED,DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,
        RCVD_IN_DNSWL_BLOCKED,SPF_HELO_NONE,SPF_PASS,T_SCC_BODY_TEXT_LINE
        autolearn=ham autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Thu, 07 Dec 2023 12:30:45 +0000,
Mark Brown <broonie@kernel.org> wrote:
> 
> On Thu, Dec 07, 2023 at 08:39:46AM +0000, Marc Zyngier wrote:
> > Mark Brown <broonie@kernel.org> wrote:
> 
> > >  #define HCRX_GUEST_FLAGS \
> > > -	(HCRX_EL2_SMPME | HCRX_EL2_TCR2En | \
> > > +	(HCRX_EL2_SMPME | HCRX_EL2_TCR2En | HCRX_EL2_EnFPM | \
> 
> > We really should start making all of these things conditional. See
> > below.
> 
> Is there an overarching theory behind how these things are intended to
> work?  I agree with you that I'd have expected more conditionality here,
> I was trying to fit in with the existing pattern.  It's kind of hard to
> follow what the intention is, I think to some extent due to things
> having evolved over time.

The intention is that *everything* becomes conditional, based on both
the host CPU support and the feature set advertised to the guest.
Which means that we don't stuff that isn't advertised to the guest,
and instead make these things UNDEF. Just like on any real CPU
implementation.

>
> > > @@ -517,7 +519,6 @@ struct kvm_vcpu_arch {
> > >  	enum fp_type fp_type;
> > >  	unsigned int sve_max_vl;
> > >  	u64 svcr;
> > > -	u64 fpmr;
> 
> > Why do this change here? Why isn't done like that the first place?
> 
> It didn't seem right to add the register to struct vcpu_sysreg before it
> was handled by KVM.  As referenced in the cover letter normally this
> wouldn't come up because KVM doesn't rely on the host kernel for
> managing register state so we add KVM support then enable the host
> kernel but for FPSIMD we're reusing fpsimd_save() so we need the host
> kernel support to be in place when we enable KVM.

That doesn't explain why you can't be upfront with it and populate the
FPMR entry. In either case, you are wasting a u64.

> 
> > >  	CGT_MDCR_TDE,
> > > @@ -279,6 +281,12 @@ static const struct trap_bits coarse_trap_bits[] = {
> > >  		.mask		= HCR_TTLBOS,
> > >  		.behaviour	= BEHAVE_FORWARD_ANY,
> > >  	},
> > > +	[CGT_HCRX_EnFPM] = {
> > > +		.index		= HCRX_EL2,
> > > +		.value		= HCRX_EL2_EnFPM,
> > > +		.mask		= HCRX_EL2_EnFPM,
> > > +		.behaviour	= BEHAVE_FORWARD_ANY,
> 
> > This looks wrong. HCRX_EL2.EnFPM is an enable bit.
> 
> Right, it's the wrong way round.
> 
> > > +static void *fpsimd_share_end(struct user_fpsimd_state *fpsimd)
> > > +{
> > > +	void *share_end = fpsimd + 1;
> > > +
> > > +	if (cpus_have_final_cap(ARM64_HAS_FPMR))
> > > +		share_end += sizeof(u64);
> > > +
> > > +	return share_end;
> > > +}
> 
> > This is horrible. Why can't you just have a new structure wrapping
> > both user_fpsimd_state and fpmr? This is going to break in subtle
> > ways, just like the SVE/SME stuff.
> 
> I agree that it's not great, the main issue was that fpsimd_state is
> both already embedded in uw for hardened usercopy and very widely
> referenced by exactly which struct it's in so I was taking a guess as to
> what would get the least objections.  The obvious thing would be to add
> FPMR to uw and share the whole thing with the hypervisor, if people
> don't mind adding another field to uw I could do that?

Either that, or you create a KVM-specific structure that contains
these fields. If that results in KVM changes, so be it. But I won't
take this sort of pointer arithmetic that assumes some pre-defined
layout.

> 
> > >  	vcpu->arch.host_fpsimd_state = kern_hyp_va(fpsimd);
> > > +	if (cpus_have_final_cap(ARM64_HAS_FPMR)) {
> > > +		WARN_ON_ONCE(&current->thread.fpmr + 1 != fpsimd_share_end(fpsimd));
> 
> > How can this happen?
> 
> It shouldn't, but it'd be bad if it did so I put a check in to make sure
> we haven't messed up.

See my earlier point: you shouldn't have to check if you used a data
structure.

> 
> > > +		vcpu->arch.host_fpmr = kern_hyp_va(&current->thread.fpmr);
> > > +	}
> 
> > We really need to stop piling the save/restore of stuff that isn't
> > advertised to the guest.
> 
> I'm not clear what you're referencing here?  The feature is advertised
> to the guest via the ID registers and in the past you've pushed back on
> making things where the state is just a single register like this
> optional.  Do you mean that we should be making this conditional on the
> guest ID registers?  If that is the case is there a plan for how that's
> supposed to work, set flags when kvm_vcpu_run_pid_change() happens for
> example?

See the beginning of this email. It is high time that we stop enabling
everything by default, because this totally breaks VM migration. We
already have a huge backlog of these things, and I don't want to add
more of it.

Which means that at the very least, enabling *any* feature also comes
with sanitising the state one way or another when this feature is
disabled by userspace.

How this is being done is still a work in progress: my current plan is
based on a set of trap bits that are computed on a per-VM basis, and
some side state that indicates whether the trap handling is for
emulation or feature disabling purpose. This will probably reuse the
NV infrastructure which has an exhaustive list of the sysregs that can
be trapped from EL0/EL1.

At the very least, userspace shouldn't be able to observe the state
that a guest isn't supposed to generate, and we should be mindful of
not creating covert channels.

	M.

-- 
Without deviation from the norm, progress is not possible.

Return-Path: <linux-kernel+bounces-12357-lists+linux-kernel=lfdr.de@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from ny.mirrors.kernel.org (ny.mirrors.kernel.org [IPv6:2604:1380:45d1:ec00::1])
	by mail.lfdr.de (Postfix) with ESMTPS id 7928B81F3AD
	for <lists+linux-kernel@lfdr.de>; Thu, 28 Dec 2023 02:40:19 +0100 (CET)
Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by ny.mirrors.kernel.org (Postfix) with ESMTPS id AB6D31C20986
	for <lists+linux-kernel@lfdr.de>; Thu, 28 Dec 2023 01:40:18 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 2AE7D79CF;
	Thu, 28 Dec 2023 01:38:19 +0000 (UTC)
X-Original-To: linux-kernel@vger.kernel.org
Received: from szxga02-in.huawei.com (szxga02-in.huawei.com [45.249.212.188])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id B6E606FAD
	for <linux-kernel@vger.kernel.org>; Thu, 28 Dec 2023 01:38:16 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.19.162.254])
	by szxga02-in.huawei.com (SkyGuard) with ESMTP id 4T0rjZ00SdzWksy;
	Thu, 28 Dec 2023 09:37:37 +0800 (CST)
Received: from kwepemm000013.china.huawei.com (unknown [7.193.23.81])
	by mail.maildlp.com (Postfix) with ESMTPS id 135F91800BF;
	Thu, 28 Dec 2023 09:38:09 +0800 (CST)
Received: from huawei.com (10.175.127.227) by kwepemm000013.china.huawei.com
 (7.193.23.81) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.35; Thu, 28 Dec
 2023 09:38:08 +0800
From: Zhihao Cheng <chengzhihao1@huawei.com>
To: <david.oberhollenzer@sigma-star.at>, <richard@nod.at>,
	<miquel.raynal@bootlin.com>, <s.hauer@pengutronix.de>,
	<Tudor.Ambarus@linaro.org>
CC: <linux-kernel@vger.kernel.org>, <linux-mtd@lists.infradead.org>
Subject: [PATCH RFC 04/17] ubifs: repair: Add valid nodes into file
Date: Thu, 28 Dec 2023 09:40:59 +0800
Message-ID: <20231228014112.2836317-5-chengzhihao1@huawei.com>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20231228014112.2836317-1-chengzhihao1@huawei.com>
References: <20231228014112.2836317-1-chengzhihao1@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: dggems706-chm.china.huawei.com (10.3.19.183) To
 kwepemm000013.china.huawei.com (7.193.23.81)

This is the 4/13 step of repairing. Generate file according to left valid
inode nodes and dentry nodes. Based on results from step 3, it is easy to
understand:

Step 3 has done:
 valid_inos - del_inos = left_inos
 valid_dents - del_dents = left_dents
Step 4 should do:
 Traverse left_inos and left_dents, insert inode/dentry nodes into
 corresponding file.

Now, all files are generated by scanning, the next thing to do is
dropping invalid files(eg. nonconsistent file type between inode node and
dentry nodes, file has no dentry nodes(excepts '/'), encrypted file has
no xattr information, etc.).

Signed-off-by: Zhihao Cheng <chengzhihao1@huawei.com>
---
 fs/ubifs/repair.c | 60 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 60 insertions(+)

diff --git a/fs/ubifs/repair.c b/fs/ubifs/repair.c
index d932c16ec893..7a1732ef903f 100644
--- a/fs/ubifs/repair.c
+++ b/fs/ubifs/repair.c
@@ -1043,6 +1043,62 @@ static void remove_del_nodes(struct ubifs_info *c, struct scanned_info *si)
 	}
 }
 
+/**
+ * add_valid_nodes_into_file - add valid nodes into file.
+ * @c: UBIFS file-system description object
+ * @si: records nodes and files information during scanning
+ *
+ * This function adds valid nodes into corresponding file, all valid ino/dent
+ * nodes will be removed from @si->valid_inos/@si->valid_dents if the function
+ * is executed successfully.
+ */
+static int add_valid_nodes_into_file(struct ubifs_info *c,
+				     struct scanned_info *si)
+{
+	int err, type;
+	ino_t inum;
+	struct scanned_node *sn;
+	struct scanned_ino_node *ino_node;
+	struct scanned_dent_node *dent_node;
+	struct rb_node *this;
+
+	this = rb_first(&si->valid_inos);
+	while (this) {
+		cond_resched();
+		ino_node = rb_entry(this, struct scanned_ino_node, rb);
+		this = rb_next(this);
+
+		sn = (struct scanned_node *)ino_node;
+		type = key_type(c, &ino_node->key);
+		inum = key_inum(c, &ino_node->key);
+		err = insert_or_update_file(c, sn, type, inum);
+		if (err)
+			return err;
+
+		rb_erase(&ino_node->rb, &si->valid_inos);
+		kfree(ino_node);
+	}
+
+	this = rb_first(&si->valid_dents);
+	while (this) {
+		cond_resched();
+		dent_node = rb_entry(this, struct scanned_dent_node, rb);
+		this = rb_next(this);
+
+		sn = (struct scanned_node *)dent_node;
+		inum = dent_node->inum;
+		type = key_type(c, &dent_node->key);
+		err = insert_or_update_file(c, sn, type, inum);
+		if (err)
+			return err;
+
+		rb_erase(&dent_node->rb, &si->valid_dents);
+		kfree(dent_node);
+	}
+
+	return 0;
+}
+
 static int do_repair(struct ubifs_info *c)
 {
 	int err = 0;
@@ -1060,6 +1116,10 @@ static int do_repair(struct ubifs_info *c)
 	ubifs_msg(c, "Step 3: Remove deleted nodes");
 	remove_del_nodes(c, &si);
 
+	/* Step 4: Add valid nodes into file. */
+	ubifs_msg(c, "Step 4: Add valid nodes into file");
+	err = add_valid_nodes_into_file(c, &si);
+
 out:
 	destroy_scanned_info(c, &si);
 	return err;
-- 
2.31.1


